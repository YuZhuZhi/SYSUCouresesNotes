# 量子计算(八)——振幅放大

## 一、问题背景

这个算法要解决的问题就是寻找符合要求的解。假设解空间可以被表示为二进制字符串，并且已知某种能够确定解空间中各个解的好坏的标准。

>也就是给出布尔函数$\mathcal{X}$，它将解空间中的解$x$映射到$\{0,1\}$：
>$$\mathcal{X}(x)=\begin{cases}
    0, & \qquad if\ x\ is\ bad\\
    1, & \qquad if\ x\ is\ good\\
\end{cases}$$

这个目标基本和$Grover$算法要解决的问题是一致的。事实上，$Grover$算法中的核心算法就是振幅放大，这篇论文就是对$Grover$算法的总结推广，<font color="#dd0000">使得任意无测量量子算法也可以使用(存疑)</font>。

### 1.量子化

显然，由于解空间被表示为二进制串，因而解空间可以作为一个希尔伯特空间，从而允许量子算法的运行。而解的好坏，则将其划分为两个子空间——称为好空间与坏空间。于是解空间的任意纯态$| \psi \rangle$都可以被分解表示为：

$$| \psi \rangle=| \psi_0 \rangle+| \psi_1 \rangle$$

其中$| \psi_0 \rangle$表示落入坏空间的部分，相应地$| \psi_1 \rangle$表示落入好空间的部分。于是$b_\psi=\langle \psi_0 | \psi_0 \rangle$表示了对这个纯态测量后得到坏结果的概率，$a_\psi=\langle \psi_1 | \psi_1 \rangle$则是得到好结果的概率。显然$a_\psi+b_\psi=1$。

到这一步，我们的目标就已经清晰明朗了：只要让好空间部分的$| \psi_1 \rangle$振幅变大，就提高了测到好结果的概率。之后只需要代入$\mathcal{X}$判定其是否确实是好结果即可。

---

## 二、振幅放大的构建

### 1.

假定$n$是解空间的二进制串的长度。假设无测量量子算法$\mathcal{A}$是作用到解空间上的酉矩阵，并假设纯态$| \Psi \rangle=\mathcal{A}| 0^n \rangle$是由其作用到初始零态的结果。
